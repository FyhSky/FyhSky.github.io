---
layout: post
title: "GCD使用注意事项"
date: 2015-11-21 15:20:00
comments: true
--- 
GCD使用注意事项
============

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;想必大家对GCD的概念都比较的熟悉，网上一搜一大堆，这里就不详细介绍了。
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;今天主要探讨一下GCD使用时候的一些注意事项，用不好的话有可能出现死锁。
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;死锁发生的场景：

     1. 使用同步函数dispatch_sync。
     2. 使用同步函数的线程跟同步函数执行的block线程为同一线程。
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;死锁原因：

     1. 同步函数会阻塞当前线程，直到block执行完成。
     2. block线程被阻塞，block一直无法执行
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;如下的代码片段就会发生死锁，程序运行只会输出：Before Block，然后程序卡住，无限的风火轮转起来。

```
- (void)testGCDDeadLock {
    dispatch_queue_t queue = dispatch_get_current_queue();
    NSLog(@"Before Block");
    dispatch_sync(queue, ^{
       NSLog(@"In Block");
    });
    NSLog(@"After Block");
}
```

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;上面的代码片段只是为了方便测试，才使用了dispatch_get_current_queue函数，该函数在OSX10.9之后就被废弃，并且该函数不好操作，用不好会发现意想不到的后果。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;GCD给我们带了了使用线程方便的同时也埋下了隐患，因此在使用GCD相关的sync函数时，要特别的注意不能让执行block的线程为当前的线程。


